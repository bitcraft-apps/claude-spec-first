name: Issue Auto-Labeler

on:
  issues:
    types: [opened, edited]

jobs:
  label-issue:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Auto-label based on content
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const issue = context.payload.issue;
              const title = issue.title.toLowerCase();
              const body = issue.body ? issue.body.toLowerCase() : '';
              const content = title + ' ' + body;
              
              const labelsToAdd = [];
              
              // Component detection based on content analysis
              const componentMappings = {
                'component:agent-spec-analyst': ['spec-analyst', 'specification analysis', 'requirements analysis', 'spec analyst'],
                'component:agent-test-designer': ['test-designer', 'test design', 'test creation', 'test designer'],
                'component:agent-arch-designer': ['arch-designer', 'architecture', 'system design', 'arch designer'],
                'component:agent-impl-specialist': ['impl-specialist', 'implementation', 'code generation', 'impl specialist'],
                'component:agent-qa-validator': ['qa-validator', 'quality assurance', 'validation', 'qa validator'],
                'component:command-spec-init': ['/spec-init', 'spec-init', 'initialize specification', 'spec init'],
                'component:command-spec-review': ['/spec-review', 'spec-review', 'review specification', 'spec review'],
                'component:command-impl-plan': ['/impl-plan', 'impl-plan', 'implementation plan', 'impl plan'],
                'component:command-qa-check': ['/qa-check', 'qa-check', 'quality check', 'qa check'],
                'component:command-spec-workflow': ['/spec-workflow', 'spec-workflow', 'complete workflow', 'spec workflow'],
                'component:installation': ['install.sh', 'installation', 'install', 'setup', 'scripts/install'],
                'component:validation': ['validate-framework.sh', 'validation', 'validate', 'framework/validate'],
                'component:docs': ['documentation', 'readme', 'docs/', 'guide', '.md']
              };
              
              // File path detection (higher priority)
              const filePaths = {
                'component:agent-spec-analyst': ['framework/agents/spec-analyst.md', 'agents/spec-analyst'],
                'component:agent-test-designer': ['framework/agents/test-designer.md', 'agents/test-designer'],
                'component:agent-arch-designer': ['framework/agents/arch-designer.md', 'agents/arch-designer'],
                'component:agent-impl-specialist': ['framework/agents/impl-specialist.md', 'agents/impl-specialist'],
                'component:agent-qa-validator': ['framework/agents/qa-validator.md', 'agents/qa-validator'],
                'component:command-spec-init': ['framework/commands/spec-init.md', 'commands/spec-init'],
                'component:command-spec-review': ['framework/commands/spec-review.md', 'commands/spec-review'],
                'component:command-impl-plan': ['framework/commands/impl-plan.md', 'commands/impl-plan'],
                'component:command-qa-check': ['framework/commands/qa-check.md', 'commands/qa-check'],
                'component:command-spec-workflow': ['framework/commands/spec-workflow.md', 'commands/spec-workflow'],
                'component:installation': ['scripts/install.sh', 'scripts/update.sh', 'scripts/uninstall.sh'],
                'component:validation': ['framework/validate-framework.sh', 'validate-framework'],
                'component:docs': ['README.md', 'docs/', 'CONTRIBUTING.md']
              };
              
              // Check file paths first (higher confidence)
              let componentFound = false;
              for (const [label, paths] of Object.entries(filePaths)) {
                if (paths.some(path => content.includes(path))) {
                  labelsToAdd.push(label);
                  componentFound = true;
                  break;
                }
              }
              
              // Check content keywords if no file path match
              if (!componentFound) {
                for (const [label, keywords] of Object.entries(componentMappings)) {
                  if (keywords.some(keyword => content.includes(keyword))) {
                    labelsToAdd.push(label);
                    break; // Only add one component label
                  }
                }
              }
              
              // Priority detection based on content
              if (content.includes('critical') || content.includes('urgent') || 
                  content.includes('breaking') || content.includes('system down')) {
                labelsToAdd.push('priority:critical');
              } else if (content.includes('important') || content.includes('high priority') ||
                        content.includes('significantly') || content.includes('blocking')) {
                labelsToAdd.push('priority:high');
              } else if (content.includes('low priority') || content.includes('nice to have') ||
                        content.includes('minor') || content.includes('convenience')) {
                labelsToAdd.push('priority:low');
              } else {
                // Default to normal priority
                labelsToAdd.push('priority:normal');
              }
              
              // Security detection
              if (content.includes('security') || content.includes('vulnerability') ||
                  content.includes('exploit') || content.includes('cve')) {
                labelsToAdd.push('type:security');
                labelsToAdd.push('priority:high'); // Override normal priority for security
              }
              
              // Add labels if any were identified
              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: labelsToAdd
                });
                
                console.log(\`Added labels to issue #\${issue.number}: \${labelsToAdd.join(', ')}\`);
              } else {
                console.log(\`No specific component detected for issue #\${issue.number}\`);
              }
              
            } catch (error) {
              console.error('Auto-labeling failed:', error);
              // Don't throw - allow issue creation to succeed even if labeling fails
            }